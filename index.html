<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Daffodil Generator</title>

  <link rel="stylesheet" href="https://js.arcgis.com/4.14/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.14/"></script>

  <style>
    html,
    body,
    #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
    }

    #paneDiv {
      padding: 10px;
      max-width: 200px;
      background-color: rgba(255, 255, 255, 0.8);
      font-size: 1.1em;
    }

    #credits {
      font-size: 0.7em;
      line-height: 1.1em;
    }
  </style>
  <script>
    require([
      "esri/views/SceneView",
      "esri/WebScene",
      "esri/Map",
      "esri/Graphic",
      "esri/layers/GraphicsLayer",
      "esri/layers/FeatureLayer",
      "esri/geometry/Point",
      "esri/geometry/support/webMercatorUtils",
      "esri/widgets/Sketch/SketchViewModel",
      "esri/geometry/Mesh",
      "esri/geometry/geometryEngine"
    ], function (SceneView, WebScene, Map, Graphic, GraphicsLayer, FeatureLayer, Point, webMercatorUtils, SketchViewModel, Mesh, geometryEngine) {

      let showWidgets = false;
      let showAreaLayer = false;
      let itemId = "6d83a0e1c12b43beba2a0eb745ec552a";
      let daffodilAreasUrl = "https://services.arcgis.com/OLiydejKCZTGhvWg/arcgis/rest/services/DaffodilAreas_Coast/FeatureServer/0";
      let daffodilUrl =  "./Daffodil_426_te1.glb";
      let maxDist = 2;
      let maxHeight = 1;
      let startAt = 0;
      let modelLayerStartAt = -1;
      let modelLayerEndAt = -1;
      let speedFactor = 0.1;
      let offset = 0;
      let cameraListener = false;
      let zoomClose = false;
      let easing = "in-out-coast-quadratic";
      let view;
      let modelLayer;

      function getUrlParams() {
        const queryParams = document.location.search.substr(1);
        let result = {};

        queryParams.split("?").map((params) => {
          params.split("&").map((param) => {
            var item = param.split("=");
            result[item[0]] = decodeURIComponent(item[1]);
          })
        });

        if (result.showWidgets) showWidgets = result.showWidgets;
        if (result.showAreaLayer) showAreaLayer = result.showAreaLayer;
        if (result.itemId) itemId = result.itemId;
        if (result.daffodilAreasUrl) daffodilAreasUrl = result.daffodilAreasUrl;
        if (result.daffodilUrl) daffodilUrl = result.daffodilUrl;
        if (result.maxDist) maxDist = result.maxDist;
        if (result.maxHeight) maxHeight = result.maxHeight;
        if (result.cameraListener) cameraListener = result.cameraListener;
        if (result.zoomClose) zoomClose = result.zoomClose;
        if (result.startAt) startAt = result.startAt;
        if (result.modelLayerStartAt) modelLayerStartAt = result.modelLayerStartAt;
        if (result.modelLayerEndAt) modelLayerEndAt = result.modelLayerEndAt;
        if (result.speedFactor) speedFactor = result.speedFactor;
        if (result.offset) offset = result.offset;
        if (result.easing) easing = result.easing;
      }

      getUrlParams();

      function getRndPercent(min = 0, max = 100) {
        let rnd = Math.random() * (max - min + 1) + min;
        let pc = rnd / 100.0;
        return pc;
      }


      // when the webscene has slides, they are added in a list at the bottom
      function createPresentation(slides) {
        // when the webscene has slides, they are added in a list at the bottom
        console.log("createPresentation", slides.items);
        playAnimation(slides.items);
      }

      function playAnimation(slides) {
        if (startAt > slides.length) startAt = 0;
        aniSlideCounter = startAt;
        
        console.log("Playing flight on click", slides, view, " | speedFactor:", speedFactor, " | offset (ms):", offset, " | starting at slide ", startAt);

        view.on("click", (e) => {
          console.log("click starts animation");
          aniNextLocation(slides);
        });
      }

      function aniNextLocation(slides) {
        console.log("Approaching location #" + aniSlideCounter, slides[aniSlideCounter], slides[aniSlideCounter].viewpoint);
        new Promise((resolve) => {
          setTimeout(resolve, offset);
        }).then(() => {
          console.log("Offset over", offset);
          if (aniSlideCounter <= slides.length) {

            if ((modelLayerStartAt === -1 || modelLayerStartAt <= aniSlideCounter) && !view.map.findLayerById(modelLayer.id)) {
              view.map.add(modelLayer);
            }
            else if ((modelLayerEndAt === aniSlideCounter) && view.map.findLayerById(modelLayer.id)) {
              view.map.remove(modelLayer);
            }

            view.goTo(slides[aniSlideCounter].viewpoint, {
              animate: true,
              speedFactor: speedFactor,
              maxDuration: 1000000,
              easing: easing
            }).then(() => {
              aniNextLocation(slides)
            });
            aniSlideCounter++;
          }
        });
      }











      let coordinates = webMercatorUtils.geographicToWebMercator(
        new Point({ y: 41.391256, x: -70.632368 })
      );

      const webScene = new WebScene({
        portalItem: {
          id: itemId
        }
      });

      webScene.load((w) => {
        console.log("webScene loaded", w);
      }).then((b) => {
        console.log("basemap loaded", b);
        scene.basemap.loadAll()
          .catch((error) => {
            console.error("Basemap resource load error", error);
          })
          .then((l) => {
            console.log("All loaded", l);
          });
      });

      view = new SceneView({
        container: "viewDiv",
        map: webScene
      });

      if (!showWidgets) {
        view.ui.empty("top-left");
        view.ui.remove("attribution");
      }

      view.when(() => {

        createPresentation(webScene.presentation.slides);

        if (zoomClose) {
          let c = view.camera;
          c.position.z = 0.1;
          view.goTo(c);
        }

        if (cameraListener) {
          view.watch("camera", (c) => {
            console.log(JSON.stringify(c));
          })
        }
      });

      modelLayer = new GraphicsLayer({
        id: "modelLayer"
      });

      let daffodilAreas = new FeatureLayer({
        url: daffodilAreasUrl,
        id: "daffodilAreas"
      })
      if (showAreaLayer) view.map.add(daffodilAreas);



      // Queries for all the features in the service (not the graphics in the view)
      daffodilAreas.queryFeatures().then(function (results) {
        // prints an array of all the features in the service to the console
        console.log("daffodilAreas query", results.features);

        let allGeo = results.features.map((result) => result.geometry);
        let unGeo = geometryEngine.union(allGeo);

        console.log("result geo", allGeo, unGeo);

        let ext = unGeo.extent;
        let xDist = maxDist * getRndPercent();
        let yDist = maxDist * getRndPercent();
        let pointCounter = 0;
        let rowCounter = 0;
        for (let x = ext.xmin; x < ext.xmax; x += xDist) {
          for (let y = ext.ymin; y < ext.ymax; y += yDist) {
            let point = new Point({
              y: y,
              x: x,
              spatialReference: unGeo.spatialReference
            });
            if (geometryEngine.contains(unGeo, point)) {
              let heading = Math.random() * 360;
              let height = maxHeight * getRndPercent(50, 100);
              let graphic = new Graphic({
                geometry: point,
                symbol: {
                  type: "point-3d",
                  symbolLayers: [
                    {
                      type: "object",
                      resource: {
                        href: daffodilUrl
                      },
                      height: height,
                      heading: heading,
                    }
                  ]
                }
              });
              modelLayer.add(graphic);
              console.log("graphic ", graphic, height, heading);
              pointCounter++;
            }
            yDist = maxDist * getRndPercent();
          }
          xDist = maxDist * getRndPercent();
          rowCounter++;
          console.log("row ", rowCounter, " pointCounter", pointCounter);
        }
        console.log("total pointCounter", pointCounter);
      });

    });
  </script>
</head>

<body>
  <div id="viewDiv"></div>
</body>

</html>